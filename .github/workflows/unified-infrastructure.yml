name: Unified Infrastructure & SSO Pipeline

# This pipeline manages the complete infrastructure deployment with proper dependency ordering:
# 1. Terraform State Backend Bootstrap (creates S3 + DynamoDB for state management)
# 2. AWS Organizations & SSO (creates accounts and SSO configuration)
# 3. Infrastructure Deployment (Hetzner k3s, Cloudflare, etc.)
# 4. Validation & Testing
# 5. Security Scanning
#
# What it does:
# 1. Creates S3 bucket and DynamoDB table for Terraform state management
# 2. Sets up AWS Organization accounts (Development & Production)
# 3. Configures AWS SSO with permission sets and user groups
# 4. Deploys Hetzner k3s infrastructure
# 5. Configures Cloudflare DNS and CDN
# 6. Validates and tests the complete setup
# 7. Performs security scanning

on:
  push:
    branches: [main]
    paths:
      - "infra/**"
      - "terraform/**"
      - "k8s/**"
      - ".github/workflows/unified-infrastructure.yml"
  pull_request:
    branches: [main]
    paths:
      - "infra/**"
      - "terraform/**"
      - "k8s/**"
      - ".github/workflows/unified-infrastructure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy infrastructure to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
      action:
        description: "Action to perform"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      skip_sso:
        description: "Skip AWS SSO setup (for faster deployments when SSO is already configured)"
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: "1.8.0"
  TF_WORKING_DIR: infra
  AWS_REGION: us-east-1 # Organizations must be in us-east-1
  SSO_REGION: ap-southeast-1
  INFRA_REGION: ap-southeast-1

jobs:
  # ===== TERRAFORM STATE BACKEND BOOTSTRAP (MUST RUN FIRST) =====
  bootstrap:
    name: "Terraform State Backend Bootstrap"
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    # Skip if we're not doing a full deployment
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan'
    outputs:
      state_bucket: ${{ steps.bootstrap.outputs.state_bucket }}
      dynamodb_table: ${{ steps.bootstrap.outputs.dynamodb_table }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Variables
        run: |
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID variable is not set"
            echo "üìã Please set the MANAGEMENT_ACCOUNT_ID variable in your repository settings"
            echo "üìñ This should be the AWS account ID where bootstrap resources will be created"
            exit 1
          fi
          echo "‚úÖ MANAGEMENT_ACCOUNT_ID variable is configured"
          echo "üîç Account ID: ${{ vars.MANAGEMENT_ACCOUNT_ID }}"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Get Account ID for Bootstrap
        id: get-bootstrap-account
        run: |
          # For bootstrap, we need to determine which account to use
          # If development account exists (after SSO setup), use it
          # Otherwise, use management account as fallback

          # First, check if MANAGEMENT_ACCOUNT_ID is set
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID is not set"
            exit 1
          fi

          # For initial bootstrap, always use management account
          # The development account won't exist until after SSO setup
          ACCOUNT_ID="${{ vars.MANAGEMENT_ACCOUNT_ID }}"
          echo "Using management account for bootstrap: $ACCOUNT_ID"
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ steps.get-bootstrap-account.outputs.account_id }}:role/GitHubActionsSSORole
          aws-region: ${{ env.INFRA_REGION }}
        continue-on-error: true

      - name: Configure AWS credentials via static credentials (fallback)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Bootstrap Terraform State Backend
        id: bootstrap
        run: |
          cd ${{ env.TF_WORKING_DIR }}/bootstrap
          echo "üöÄ Bootstrapping Terraform state backend..."

          # Initialize bootstrap with local backend
          terraform init -upgrade

          # Check if bootstrap resources already exist by examining terraform state
          echo "üîç Checking for existing bootstrap state..."

          if [ -f "terraform.tfstate" ]; then
            echo "üìÑ Terraform state file exists, checking contents..."

            # Check if state contains our bootstrap resources
            STATE_BUCKET_IN_STATE=$(terraform state list | grep "module.bootstrap.module.terraform_state_bucket.aws_s3_bucket.private_bucket" || echo "")
            DYNAMODB_TABLE_IN_STATE=$(terraform state list | grep "module.bootstrap.aws_dynamodb_table.terraform_state_lock" || echo "")
            LOGS_BUCKET_IN_STATE=$(terraform state list | grep "module.bootstrap.module.terraform_state_bucket_logs.aws_s3_bucket.aws_logs" || echo "")

            if [ -n "$STATE_BUCKET_IN_STATE" ] && [ -n "$DYNAMODB_TABLE_IN_STATE" ] && [ -n "$LOGS_BUCKET_IN_STATE" ]; then
              echo "‚úÖ All bootstrap resources found in Terraform state"
              echo "‚è≠Ô∏è  Skipping terraform apply - resources already exist"

              # Get outputs from existing state
              STATE_BUCKET=$(terraform output -raw state_bucket)
              DYNAMODB_TABLE=$(terraform output -raw dynamodb_table)
            else
              echo "‚ö†Ô∏è  Some bootstrap resources missing from state, will apply..."
              terraform apply -auto-approve -var-file=terraform.tfvars
            fi
          else
            echo "üìù No existing terraform state found, creating bootstrap resources..."
            terraform apply -auto-approve -var-file=terraform.tfvars
          fi

          # Ensure we have the outputs
          if [ -z "$STATE_BUCKET" ]; then
            STATE_BUCKET=$(terraform output -raw state_bucket)
          fi
          if [ -z "$DYNAMODB_TABLE" ]; then
            DYNAMODB_TABLE=$(terraform output -raw dynamodb_table)
          fi

          echo "‚úÖ Terraform state backend bootstrapped successfully"

          echo "state_bucket=$STATE_BUCKET" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$DYNAMODB_TABLE" >> $GITHUB_OUTPUT

          echo "üìã Bootstrap outputs:"
          echo "  - State Bucket: $STATE_BUCKET"
          echo "  - DynamoDB Table: $DYNAMODB_TABLE"

      - name: Commit Bootstrap State
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          cd ${{ env.TF_WORKING_DIR }}/bootstrap

          # Check if there are changes to commit
          if git diff --quiet terraform.tfstate; then
            echo "‚ÑπÔ∏è  No changes to bootstrap state file"
          else
            echo "üìù Committing bootstrap state changes..."

            git config --global user.name "GitHub Actions"
            git config --global user.email "actions@github.com"

            git add terraform.tfstate
            git commit -m "ü§ñ Bootstrap: Update Terraform state backend

              - S3 bucket: ${{ steps.bootstrap.outputs.state_bucket }}
              - DynamoDB table: ${{ steps.bootstrap.outputs.dynamodb_table }}
              - Auto-generated by GitHub Actions workflow"

            git push origin main

            echo "‚úÖ Bootstrap state committed to repository"
          fi

  # ===== AWS ORGANIZATIONS & SSO SETUP =====
  sso-setup:
    name: "AWS Organizations & SSO Setup"
    runs-on: ubuntu-latest
    needs: [bootstrap]
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    outputs:
      development_account_id: ${{ steps.get-dev-account.outputs.account_id }}
    # Skip SSO setup if explicitly requested
    if: github.event.inputs.skip_sso != true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate Variables
        run: |
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID variable is not set"
            echo "üìã Please set the MANAGEMENT_ACCOUNT_ID variable in your repository settings"
            echo "üìñ See infra/sso/AWS_SETUP_GUIDE.md for detailed setup instructions"
            exit 1
          fi
          echo "‚úÖ MANAGEMENT_ACCOUNT_ID variable is configured"
          echo "üîç Account ID: ${{ vars.MANAGEMENT_ACCOUNT_ID }}"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/GitHubActionsSSORole
          aws-region: ${{ env.AWS_REGION }}
        timeout-minutes: 5

      - name: Configure AWS Credentials for SSO Region
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/GitHubActionsSSORole
          aws-region: ${{ env.SSO_REGION }}
          role-session-name: SSOConfig
        timeout-minutes: 5

      - name: Validate AWS Credentials
        run: |
          echo "Validating AWS credentials..."
          aws sts get-caller-identity
          echo "AWS credentials configured successfully"

      - name: Validate Account Creation Prerequisites
        run: |
          echo "üîç Validating prerequisites for AWS account creation..."

          # Check if organization already exists
          if aws organizations describe-organization >/dev/null 2>&1; then
            echo "‚úÖ AWS Organization already exists"
            aws organizations describe-organization | jq '.Organization.Id'
          else
            echo "‚ÑπÔ∏è  AWS Organization will be created"
          fi

          # Check if SSO is already enabled
          if aws sso-admin list-instances >/dev/null 2>&1; then
            echo "‚úÖ AWS SSO is already enabled"
          else
            echo "‚ÑπÔ∏è  AWS SSO will be enabled during deployment"
          fi

      - name: Terraform Format
        id: fmt
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform init -input=false -upgrade

      - name: Terraform Validate
        id: validate
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform validate -no-color

      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request'
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform plan -no-color -input=false \
            -var-file="dev.tfvars" \
            -var="hcloud_token=dummy" \
            -var="cloudflare_api_token=dummy" \
            -var="aws_ses_account_id=dummy" \
            -var="database_url=dummy" \
            -var="cache_database_url=dummy" \
            -var="secret_key_base=dummy" \
            -var="ruby_llm_api_key=dummy" \
            -var="aws_ses_access_key_id=dummy" \
            -var="aws_ses_secret_access_key=dummy" \
            -var="hetzner_object_storage_access_key=dummy" \
            -var="hetzner_object_storage_secret_key=dummy" \
            -var="stripe_api_key=dummy" \
            -var="stripe_webhook_secret=dummy" \
            -var="ssh_private_key=dummy" \
            -var="ssh_public_key=dummy"
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### AWS Organizations & SSO Setup üèóÔ∏è
            #### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Validate Terraform Plan
        if: github.event_name == 'pull_request'
        run: |
          echo "üîç Validating Terraform plan for account creation and SSO assignments..."

          # Check if plan contains expected resources
          if echo "${{ steps.plan.outputs.stdout }}" | grep -q "aws_organizations_account"; then
            echo "‚úÖ Plan contains AWS account creation"
          else
            echo "‚ö†Ô∏è  No AWS account creation found in plan"
          fi

          if echo "${{ steps.plan.outputs.stdout }}" | grep -q "aws_ssoadmin_account_assignment"; then
            echo "‚úÖ Plan contains SSO account assignments"
          else
            echo "‚ö†Ô∏è  No SSO account assignments found in plan"
          fi

          # Check for empty account IDs (the original error)
          if echo "${{ steps.plan.outputs.stdout }}" | grep -q 'target_id.*""'; then
            echo "‚ùå ERROR: Found empty account IDs in plan - this will cause SSO assignment failures"
            exit 1
          else
            echo "‚úÖ No empty account IDs found in plan"
          fi

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        env:
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN || '' }}
          TF_VAR_aws_ses_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          echo "üöÄ Applying AWS Organizations and SSO configuration..."

          # Apply with dummy values for non-AWS variables
          terraform apply -auto-approve -input=false \
            -var-file="dev.tfvars" \
            -var="database_url=dummy" \
            -var="cache_database_url=dummy" \
            -var="secret_key_base=dummy" \
            -var="ruby_llm_api_key=dummy" \
            -var="aws_ses_access_key_id=dummy" \
            -var="aws_ses_secret_access_key=dummy" \
            -var="hetzner_object_storage_access_key=dummy" \
            -var="hetzner_object_storage_secret_key=dummy" \
            -var="stripe_api_key=dummy" \
            -var="stripe_webhook_secret=dummy" \
            -var="ssh_private_key=dummy" \
            -var="ssh_public_key=dummy"

          echo "‚úÖ AWS Organizations and SSO configuration applied successfully"

          # Get the development account ID for SES configuration
          echo "üìã Getting development account ID for SES..."
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id 2>/dev/null || echo "${{ vars.MANAGEMENT_ACCOUNT_ID }}")
          echo "Using account ID for SES: $DEV_ACCOUNT_ID"

          # Export the development account ID for use in subsequent steps
          echo "DEV_ACCOUNT_ID=$DEV_ACCOUNT_ID" >> $GITHUB_ENV

          # Show the created account IDs
          echo "üìã Created AWS Account IDs:"
          terraform output -json | jq '.development_account_id.value, .production_account_id.value'

      - name: Get Development Account ID
        id: get-dev-account
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id 2>/dev/null || echo "${{ vars.MANAGEMENT_ACCOUNT_ID }}")
          echo "account_id=$DEV_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "Using development account ID: $DEV_ACCOUNT_ID"

      - name: Verify SSO Configuration
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "üîç Verifying SSO configuration..."

          # Check if SSO instances exist
          if aws sso-admin list-instances --region ${{ env.SSO_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ AWS SSO is properly configured"
            aws sso-admin list-instances --region ${{ env.SSO_REGION }} | jq '.Instances[] | {InstanceArn, IdentityStoreId}'
          else
            echo "‚ö†Ô∏è  AWS SSO configuration may be incomplete"
          fi

          # Check account assignments for development account
          echo "üìã SSO Account Assignments (Development):"
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id)
          if [ -n "$DEV_ACCOUNT_ID" ]; then
            aws sso-admin list-account-assignments --region ${{ env.SSO_REGION }} \
              --account-id "$DEV_ACCOUNT_ID" \
              --permission-set-arn $(aws sso-admin list-permission-sets --region ${{ env.SSO_REGION }} | jq -r '.PermissionSets[0]') 2>/dev/null || echo "No assignments found for development account"
          fi

          # Check account assignments for production account
          echo "üìã SSO Account Assignments (Production):"
          PROD_ACCOUNT_ID=$(terraform output -raw production_account_id)
          if [ -n "$PROD_ACCOUNT_ID" ]; then
            aws sso-admin list-account-assignments --region ${{ env.SSO_REGION }} \
              --account-id "$PROD_ACCOUNT_ID" \
              --permission-set-arn $(aws sso-admin list-permission-sets --region ${{ env.SSO_REGION }} | jq -r '.PermissionSets[0]') 2>/dev/null || echo "No assignments found for production account"
          fi
        working-directory: ${{ env.TF_WORKING_DIR }}

  # ===== INFRASTRUCTURE DEPLOYMENT (DEPENDS ON BOOTSTRAP & SSO) =====
  infrastructure-deploy:
    name: "Infrastructure Deployment"
    runs-on: ubuntu-latest
    needs: [sso-setup, bootstrap]
    # Skip if SSO was skipped and we're not doing a full deployment
    if: (needs.sso-setup.result == 'success' || needs.sso-setup.result == 'skipped') && (needs.bootstrap.result == 'success') && (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.DEVELOPMENT_ACCOUNT_ID }}:role/GitHubActionsSESRole
          aws-region: ${{ env.INFRA_REGION }}

      - name: Terraform Init
        id: init
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform init -upgrade

      - name: Terraform Validate
        id: validate
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform validate

      - name: Terraform Format Check
        id: fmt
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform fmt -check -recursive

      - name: Terraform Plan
        id: tf-plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        env:
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN || '' }}
          TF_VAR_aws_ses_account_id: ${{ needs.sso-setup.outputs.development_account_id }}
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && steps.tf-plan.outcome == 'success'
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Infrastructure Deployment üèóÔ∏è
            #### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.tf-plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Terraform Apply
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        env:
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN || '' }}
          TF_VAR_aws_ses_account_id: ${{ needs.sso-setup.outputs.development_account_id }}
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform destroy -auto-approve

  # ===== VALIDATION & TESTING =====
  validate:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    needs: [infrastructure-deploy, bootstrap]
    outputs:
      tf_plan_exitcode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.DEVELOPMENT_ACCOUNT_ID }}:role/GitHubActionsSESRole
          aws-region: ${{ env.INFRA_REGION }}

      - name: Terraform Init
        id: init
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform init -upgrade

      - name: Terraform Validate
        id: validate
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform validate

      - name: Terraform Format Check
        id: fmt
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform fmt -check -recursive

      - name: Terraform Plan
        id: tf-plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && steps.tf-plan.outcome == 'success'
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.tf-plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  test-terraform:
    name: Test Terraform Configuration
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Test Development Configuration
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -backend=false
          terraform plan -var-file="dev.tfvars" -no-color -out=tfplan-dev
          terraform show -json tfplan-dev > tfplan-dev.json

      - name: Test Production Configuration
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform plan -var-file="prod.tfvars" -no-color -out=tfplan-prod
          terraform show -json tfplan-prod > tfplan-prod.json

      - name: Validate Plan Outputs
        run: |
          # Check that plans were generated successfully
          if [ ! -f "${{ env.TF_WORKING_DIR }}/tfplan-dev.json" ] || [ ! -f "${{ env.TF_WORKING_DIR }}/tfplan-prod.json" ]; then
            echo "‚ùå Plan files not generated"
            exit 1
          fi

          # Check for errors in plans
          if grep -q '"error"' ${{ env.TF_WORKING_DIR }}/tfplan-dev.json || grep -q '"error"' ${{ env.TF_WORKING_DIR }}/tfplan-prod.json; then
            echo "‚ùå Errors found in terraform plans"
            cat ${{ env.TF_WORKING_DIR }}/tfplan-dev.json
            cat ${{ env.TF_WORKING_DIR }}/tfplan-prod.json
            exit 1
          fi

          echo "‚úÖ Terraform plans validated successfully"

  security-scan:
    name: Security and Compliance Scan
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "config"
          scan-ref: "./terraform"
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

  notify:
    name: Deployment Results
    runs-on: ubuntu-latest
    needs:
      [
        sso-setup,
        bootstrap,
        infrastructure-deploy,
        validate,
        test-terraform,
        security-scan,
      ]
    if: always()

    steps:
      - name: Create deployment summary
        run: |
          echo "## üöÄ Unified Infrastructure Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # SSO Setup Results
          if [ "${{ needs.sso-setup.result }}" == "success" ]; then
            echo "‚úÖ **AWS Organizations & SSO:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.sso-setup.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è **AWS Organizations & SSO:** Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **AWS Organizations & SSO:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Bootstrap Results
          if [ "${{ needs.bootstrap.result }}" == "success" ]; then
            echo "‚úÖ **Terraform State Backend:** Bootstrapped successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform State Backend:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Infrastructure Deployment Results
          if [ "${{ needs.infrastructure-deploy.result }}" == "success" ]; then
            echo "‚úÖ **Infrastructure Deployment:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Infrastructure Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Validation Results
          if [ "${{ needs.validate.result }}" == "success" ]; then
            echo "‚úÖ **Terraform Validation:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform Validation:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Testing Results
          if [ "${{ needs.test-terraform.result }}" == "success" ]; then
            echo "‚úÖ **Terraform Testing:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform Testing:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Security Scan Results
          if [ "${{ needs.security-scan.result }}" == "success" ]; then
            echo "‚úÖ **Security Scan:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Security Scan:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Architecture:" >> $GITHUB_STEP_SUMMARY
          echo "- **Cloud Provider:** Hetzner Cloud (k3s)" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** Singapore (ap-southeast-1)" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Organizations:** Multi-account setup" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS SSO:** Centralized identity management" >> $GITHUB_STEP_SUMMARY
          echo "- **Terraform State:** S3 + DynamoDB backend" >> $GITHUB_STEP_SUMMARY
          echo "- **DNS:** Cloudflare" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Registry:** GitHub Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "- **GitOps:** ArgoCD" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring:** Prometheus + Grafana" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Quick Links:" >> $GITHUB_STEP_SUMMARY
          echo "- [Application](https://magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [ArgoCD](https://argocd.magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [Grafana](https://grafana.magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [Kubeconfig](https://github.com/magebase/site/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
