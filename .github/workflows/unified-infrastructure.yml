name: Unified Infrastructure & SSO Pipeline

# This pipeline manages the complete infrastructure deployment with proper dependency ordering:
# 1. Terraform State Backend Bootstrap (creates S3 + DynamoDB for state management)
# 2. AWS Organizations & SSO (creates accounts and SSO configuration)
# 3. Infrastructure Deployment (Hetzner k3s, Cloudflare, etc.)
# 4. Validation & Testing
# 5. Security Scanning
#
# What it does:
# 1. Creates S3 bucket and DynamoDB table for Terraform state management
# 2. Sets up AWS Organization accounts (Development & Production)
# 3. Configures AWS SSO with permission sets and user groups
# 4. Deploys Hetzner k3s infrastructure
# 5. Configures Cloudflare DNS and CDN
# 6. Validates and tests the complete setup
# 7. Performs security scanning

on:
  push:
    branches: [main]
    paths:
      - "infra/**"
      - "terraform/**"
      - "k8s/**"
      - ".github/workflows/unified-infrastructure.yml"
  pull_request:
    branches: [main]
    paths:
      - "infra/**"
      - "terraform/**"
      - "k8s/**"
      - ".github/workflows/unified-infrastructure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy infrastructure to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
      action:
        description: "Action to perform"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      skip_sso:
        description: "Skip AWS SSO setup (for faster deployments when SSO is already configured)"
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: "1.8.0"
  AWS_REGION: us-east-1 # Organizations must be in us-east-1
  SSO_REGION: ap-southeast-1
  INFRA_REGION: ap-southeast-1

jobs:
  # ===== TERRAFORM STATE BACKEND BOOTSTRAP (MUST RUN FIRST) =====
  bootstrap:
    name: "Terraform State Backend Bootstrap"
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TF_WORKING_DIR: infra/pipeline
    # Skip if we're not doing a full deployment
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan'
    outputs:
      state_bucket: ${{ steps.bootstrap.outputs.state_bucket }}
      dynamodb_table: ${{ steps.bootstrap.outputs.dynamodb_table }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Variables
        run: |
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID variable is not set"
            echo "üìã Please set the MANAGEMENT_ACCOUNT_ID variable in your repository settings"
            echo "üìñ This should be the AWS account ID where bootstrap resources will be created"
            exit 1
          fi
          echo "‚úÖ MANAGEMENT_ACCOUNT_ID variable is configured"
          echo "üîç Account ID: ${{ vars.MANAGEMENT_ACCOUNT_ID }}"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Get Account ID for Bootstrap
        id: get-bootstrap-account
        run: |
          # For bootstrap, we need to determine which account to use
          # If development account exists (after SSO setup), use it
          # Otherwise, use management account as fallback

          # First, check if MANAGEMENT_ACCOUNT_ID is set
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID is not set"
            exit 1
          fi

          # For initial bootstrap, always use management account
          # The development account won't exist until after SSO setup
          ACCOUNT_ID="${{ vars.MANAGEMENT_ACCOUNT_ID }}"
          echo "Using management account for bootstrap: $ACCOUNT_ID"
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ steps.get-bootstrap-account.outputs.account_id }}:role/GitHubActionsSSORole
          aws-region: ${{ env.INFRA_REGION }}
        continue-on-error: true

      - name: Configure AWS credentials via static credentials (fallback)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Bootstrap Terraform State Backend
        id: bootstrap
        run: |
          cd ${{ env.TF_WORKING_DIR }}/bootstrap
          echo "üöÄ Bootstrapping Terraform state backend..."

          # Expected resource names based on bootstrap configuration
          STATE_BUCKET="magebase-tf-state-bootstrap-ap-southeast-1"
          LOGS_BUCKET="magebase-tf-state-bootstrap-log-ap-southeast-1"
          DYNAMODB_TABLE="magebase-terraform-locks-bootstrap"

          echo "üìã Expected resources:"
          echo "  - State Bucket: $STATE_BUCKET"
          echo "  - Logs Bucket: $LOGS_BUCKET"
          echo "  - DynamoDB Table: $DYNAMODB_TABLE"

          # Check if bootstrap resources already exist in AWS
          echo "üîç Checking for existing bootstrap resources in AWS..."

          STATE_BUCKET_EXISTS=false
          LOGS_BUCKET_EXISTS=false
          DYNAMODB_TABLE_EXISTS=false

          # Check S3 state bucket
          if aws s3 ls "s3://$STATE_BUCKET" >/dev/null 2>&1; then
            echo "‚úÖ State bucket $STATE_BUCKET exists"
            STATE_BUCKET_EXISTS=true
          else
            echo "‚ÑπÔ∏è  State bucket $STATE_BUCKET does not exist"
          fi

          # Check S3 logs bucket
          if aws s3 ls "s3://$LOGS_BUCKET" >/dev/null 2>&1; then
            echo "‚úÖ Logs bucket $LOGS_BUCKET exists"
            LOGS_BUCKET_EXISTS=true
          else
            echo "‚ÑπÔ∏è  Logs bucket $LOGS_BUCKET does not exist"
          fi

          # Check DynamoDB table
          if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" >/dev/null 2>&1; then
            echo "‚úÖ DynamoDB table $DYNAMODB_TABLE exists"
            DYNAMODB_TABLE_EXISTS=true
          else
            echo "‚ÑπÔ∏è  DynamoDB table $DYNAMODB_TABLE does not exist"
          fi

          # If all resources exist, skip bootstrap entirely
          if [ "$STATE_BUCKET_EXISTS" = true ] && [ "$LOGS_BUCKET_EXISTS" = true ] && [ "$DYNAMODB_TABLE_EXISTS" = true ]; then
            echo "‚úÖ All bootstrap resources already exist - skipping bootstrap module"
            echo "‚è≠Ô∏è  Bootstrap resources are ready for use"

            # Set outputs for existing resources
            STATE_BUCKET="$STATE_BUCKET"
            DYNAMODB_TABLE="$DYNAMODB_TABLE"

          else
            echo "‚ÑπÔ∏è  Some bootstrap resources missing, running bootstrap module..."

            # Initialize Terraform
            terraform init -upgrade

            # Apply bootstrap module to create missing resources
            terraform apply -auto-approve -var-file=terraform.tfvars

            # Get outputs from newly created resources
            STATE_BUCKET=$(terraform output -raw state_bucket 2>/dev/null || echo "$STATE_BUCKET")
            DYNAMODB_TABLE=$(terraform output -raw dynamodb_table 2>/dev/null || echo "$DYNAMODB_TABLE")
          fi

          echo "‚úÖ Terraform state backend ready"

          echo "state_bucket=$STATE_BUCKET" >> $GITHUB_OUTPUT
          echo "dynamodb_table=$DYNAMODB_TABLE" >> $GITHUB_OUTPUT

          echo "üìã Bootstrap outputs:"
          echo "  - State Bucket: $STATE_BUCKET"
          echo "  - DynamoDB Table: $DYNAMODB_TABLE"

      - name: Force Unlock Bootstrap on Failure
        if: failure() && (github.ref == 'refs/heads/main' && github.event_name == 'push')
        run: |
          cd ${{ env.TF_WORKING_DIR }}/bootstrap
          echo "üîç Attempting to force unlock bootstrap Terraform state after failure..."

          # For bootstrap, we use a different DynamoDB table
          DYNAMODB_TABLE="magebase-terraform-locks-bootstrap"

          # Try to scan DynamoDB for any existing locks
          echo "üîç Scanning DynamoDB for existing bootstrap locks..."
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "$DYNAMODB_TABLE" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "üîí Found $LOCK_COUNT existing bootstrap state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "üîì Attempting to force unlock bootstrap: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID" 2>/dev/null; then
                  echo "‚úÖ Successfully force unlocked bootstrap: $LOCK_ID"
                  break
                else
                  echo "‚ö†Ô∏è  Force unlock failed for bootstrap: $LOCK_ID"
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è  No bootstrap locks found in DynamoDB table"
          fi

          # Provide manual instructions
          echo ""
          echo "üìã If the automatic unlock failed, please manually force-unlock the bootstrap state:"
          echo "1. Find the lock ID from the failed bootstrap step logs above"
          echo "2. Run: cd infra/pipeline/bootstrap && terraform force-unlock -force <lock_id>"
          echo "3. Re-run the workflow"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.INFRA_REGION }}

      - name: Commit Bootstrap State
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          cd ${{ env.TF_WORKING_DIR }}/bootstrap

          # Check if terraform.tfstate exists and has changes
          if [ -f "terraform.tfstate" ]; then
            if git diff --quiet terraform.tfstate; then
              echo "‚ÑπÔ∏è  No changes to bootstrap state file"
            else
              echo "üìù Committing bootstrap state changes..."

              git config --global user.name "GitHub Actions"
              git config --global user.email "actions@github.com"

              git add terraform.tfstate
              git commit -m "ü§ñ Bootstrap: Update Terraform state backend

                - S3 bucket: ${{ steps.bootstrap.outputs.state_bucket }}
                - DynamoDB table: ${{ steps.bootstrap.outputs.dynamodb_table }}
                - Auto-generated by GitHub Actions workflow"

              git push origin main

              echo "‚úÖ Bootstrap state committed to repository"
            fi
          else
            echo "‚ÑπÔ∏è  No bootstrap state file found to commit"
          fi

  # ===== AWS ORGANIZATIONS & SSO SETUP =====
  sso-setup:
    name: "AWS Organizations & SSO Setup"
    runs-on: ubuntu-latest
    needs: [bootstrap]
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    outputs:
      development_account_id: ${{ steps.get-dev-account.outputs.account_id }}
    # Skip SSO setup if explicitly requested
    if: github.event.inputs.skip_sso != true
    defaults:
      run:
        working-directory: infra/pipeline/org-sso

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate Variables
        run: |
          if [ -z "${{ vars.MANAGEMENT_ACCOUNT_ID }}" ]; then
            echo "‚ùå Error: MANAGEMENT_ACCOUNT_ID variable is not set"
            echo "üìã Please set the MANAGEMENT_ACCOUNT_ID variable in your repository settings"
            echo "üìñ See infra/pipeline/org-sso/sso-README.md for detailed setup instructions"
            exit 1
          fi
          echo "‚úÖ MANAGEMENT_ACCOUNT_ID variable is configured"
          echo "üîç Account ID: ${{ vars.MANAGEMENT_ACCOUNT_ID }}"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/GitHubActionsSSORole
          aws-region: ${{ env.AWS_REGION }}
        timeout-minutes: 5

      - name: Configure AWS Credentials for SSO Region
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/GitHubActionsSSORole
          aws-region: ${{ env.SSO_REGION }}
          role-session-name: SSOConfig
        timeout-minutes: 5

      - name: Validate AWS Credentials
        run: |
          echo "Validating AWS credentials..."
          aws sts get-caller-identity
          echo "AWS credentials configured successfully"

      - name: Validate Account Creation Prerequisites
        run: |
          echo "üîç Validating prerequisites for AWS account creation..."

          # Check if organization already exists
          if aws organizations describe-organization >/dev/null 2>&1; then
            echo "‚úÖ AWS Organization already exists"
            aws organizations describe-organization | jq '.Organization.Id'
          else
            echo "‚ÑπÔ∏è  AWS Organization will be created"
          fi

          # Check if SSO is already enabled
          if aws sso-admin list-instances >/dev/null 2>&1; then
            echo "‚úÖ AWS SSO is already enabled"
          else
            echo "‚ÑπÔ∏è  AWS SSO will be enabled during deployment"
          fi

      - name: Terraform Format
        id: fmt
        working-directory: infra/pipeline/org-sso
        run: |
          terraform fmt -check -recursive
        continue-on-error: true

      - name: Handle State Locks
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        working-directory: infra/pipeline/org-sso
        run: |
          echo "üîç Checking for existing Terraform state locks..."

          # Scan DynamoDB table for any existing locks
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "magebase-terraform-locks-bootstrap" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          # Check if we found any lock items
          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "üîí Found $LOCK_COUNT existing state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "üîì Force unlocking state with ID: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID"; then
                  echo "‚úÖ Successfully unlocked: $LOCK_ID"
                else
                  echo "‚ö†Ô∏è  Force unlock failed for: $LOCK_ID"
                  # Continue anyway - sometimes locks are stale and will be overwritten
                fi
              else
                echo "‚ö†Ô∏è  Could not extract lock ID from item $i"
              fi
            done
          else
            echo "‚úÖ No state locks found"
          fi

          echo "üîÑ Proceeding with Terraform operations..."

      - name: Terraform Init
        working-directory: infra/pipeline/org-sso
        run: |
          terraform init -input=false -upgrade

      - name: Terraform Validate
        id: validate
        working-directory: infra/pipeline/org-sso
        run: |
          terraform validate -no-color

      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request'
        working-directory: infra/pipeline/org-sso
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN || 'dummy' }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID || 'dummy' }}
        run: |
          terraform plan -no-color -input=false \
            -var-file="terraform.tfvars" \
            -var="hcloud_token=dummy" \
            -var="aws_ses_account_id=dummy" \
            -var="database_url=dummy" \
            -var="cache_database_url=dummy" \
            -var="secret_key_base=dummy" \
            -var="ruby_llm_api_key=dummy" \
            -var="aws_ses_access_key_id=dummy" \
            -var="aws_ses_secret_access_key=dummy" \
            -var="hetzner_object_storage_access_key=dummy" \
            -var="hetzner_object_storage_secret_key=dummy" \
            -var="stripe_api_key=dummy" \
            -var="stripe_webhook_secret=dummy" \
            -var="ssh_private_key=dummy" \
            -var="_key=dummy"
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### AWS Organizations & SSO Setup üèóÔ∏è
            #### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Validate Terraform Plan
        if: github.event_name == 'pull_request'
        run: |
          echo "üîç Validating Terraform plan for account creation and SSO assignments..."

          # Check if plan contains expected resources
          if echo "${{ steps.plan.outputs.stdout }}" | grep -q "aws_organizations_account"; then
            echo "‚úÖ Plan contains AWS account creation"
          else
            echo "‚ö†Ô∏è  No AWS account creation found in plan"
          fi

          if echo "${{ steps.plan.outputs.stdout }}" | grep -q "aws_ssoadmin_account_assignment"; then
            echo "‚úÖ Plan contains SSO account assignments"
          else
            echo "‚ö†Ô∏è  No SSO account assignments found in plan"
          fi

          # Check for empty account IDs (the original error)
          if echo "${{ steps.plan.outputs.stdout }}" | grep -q 'target_id.*""'; then
            echo "‚ùå ERROR: Found empty account IDs in plan - this will cause SSO assignment failures"
            exit 1
          else
            echo "‚úÖ No empty account IDs found in plan"
          fi

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        working-directory: infra/pipeline/org-sso
        env:
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
        run: |
          echo "üöÄ Applying AWS Organizations and SSO configuration..."

          # Apply with dummy values for non-AWS variables
          terraform apply -auto-approve -input=false \
            -var-file="terraform.tfvars"

          echo "‚úÖ AWS Organizations and SSO configuration applied successfully"

          # Get the development account ID for SES configuration
          echo "üìã Getting development account ID for SES..."
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id 2>/dev/null || echo "${{ vars.MANAGEMENT_ACCOUNT_ID }}")
          echo "Using account ID for SES: $DEV_ACCOUNT_ID"

          # Export the development account ID for use in subsequent steps
          echo "DEV_ACCOUNT_ID=$DEV_ACCOUNT_ID" >> $GITHUB_ENV

          # Show the created account IDs
          echo "üìã Created AWS Account IDs:"
          terraform output -json | jq '.development_account_id.value, .production_account_id.value'

      - name: Force Unlock on Failure
        if: failure() && (github.ref == 'refs/heads/main' && github.event_name == 'push')
        working-directory: infra/pipeline/org-sso
        run: |
          echo "üîç Attempting to force unlock Terraform state after failure..."

          # Try to extract lock ID from previous step's output (if available)
          # This is a best-effort attempt - the lock ID might not be in the logs

          # First, try to scan DynamoDB for any existing locks
          echo "üîç Scanning DynamoDB for existing locks..."
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "magebase-terraform-locks-bootstrap" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "üîí Found $LOCK_COUNT existing state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "üîì Attempting to force unlock: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID" 2>/dev/null; then
                  echo "‚úÖ Successfully force unlocked: $LOCK_ID"
                  break
                else
                  echo "‚ö†Ô∏è  Force unlock failed for: $LOCK_ID"
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è  No locks found in DynamoDB table"
          fi

          # If we couldn't find locks in DynamoDB, provide manual instructions
          echo ""
          echo "üìã If the automatic unlock failed, please manually force-unlock the state:"
          echo "1. Find the lock ID from the failed 'Terraform Apply' step logs above"
          echo "2. Look for: 'Lock Info: ID: <lock_id>'"
          echo "3. Run: terraform force-unlock -force <lock_id>"
          echo "4. Re-run the workflow"
          echo ""
          echo "Example lock ID from your error: 533db39e-ed09-5a60-b296-223c142784e5"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.INFRA_REGION }}

      - name: Get Development Account ID
        id: get-dev-account
        working-directory: infra/pipeline/org-sso
        run: |
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id 2>/dev/null || echo "${{ vars.MANAGEMENT_ACCOUNT_ID }}")
          echo "account_id=$DEV_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "Using development account ID: $DEV_ACCOUNT_ID"

      - name: Verify SSO Configuration
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        working-directory: infra/pipeline/org-sso
        run: |
          echo "üîç Verifying SSO configuration..."

          # Check if SSO instances exist
          if aws sso-admin list-instances --region ${{ env.SSO_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ AWS SSO is properly configured"
            aws sso-admin list-instances --region ${{ env.SSO_REGION }} | jq '.Instances[] | {InstanceArn, IdentityStoreId}'
          else
            echo "‚ö†Ô∏è  AWS SSO configuration may be incomplete"
          fi

          # Check account assignments for development account
          echo "üìã SSO Account Assignments (Development):"
          DEV_ACCOUNT_ID=$(terraform output -raw development_account_id)
          if [ -n "$DEV_ACCOUNT_ID" ]; then
            aws sso-admin list-account-assignments --region ${{ env.SSO_REGION }} \
              --account-id "$DEV_ACCOUNT_ID" \
              --permission-set-arn $(aws sso-admin list-permission-sets --region ${{ env.SSO_REGION }} | jq -r '.PermissionSets[0]') 2>/dev/null || echo "No assignments found for development account"
          fi

          # Check account assignments for production account
          echo "üìã SSO Account Assignments (Production):"
          PROD_ACCOUNT_ID=$(terraform output -raw production_account_id)
          if [ -n "$PROD_ACCOUNT_ID" ]; then
            aws sso-admin list-account-assignments --region ${{ env.SSO_REGION }} \
              --account-id "$PROD_ACCOUNT_ID" \
              --permission-set-arn $(aws sso-admin list-permission-sets --region ${{ env.SSO_REGION }} | jq -r '.PermissionSets[0]') 2>/dev/null || echo "No assignments found for production account"
          fi

  # ===== INFRASTRUCTURE DEPLOYMENT (DEPENDS ON BOOTSTRAP & SSO) =====
  infrastructure-deploy:
    name: "Infrastructure Deployment"
    runs-on: ubuntu-latest
    needs: [sso-setup, bootstrap]
    permissions:
      id-token: write
      contents: read
    # Skip if SSO was skipped and we're not doing a full deployment
    if: (needs.sso-setup.result == 'success' || needs.sso-setup.result == 'skipped') && (needs.bootstrap.result == 'success') && (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan')
    defaults:
      run:
        working-directory: infra/pipeline/main-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Get Infrastructure Account ID
        id: get-infra-account
        run: |
          # Use development account if SSO setup succeeded, otherwise use management account
          if [ "${{ needs.sso-setup.result }}" == "success" ] && [ -n "${{ needs.sso-setup.outputs.development_account_id }}" ]; then
            ACCOUNT_ID="${{ needs.sso-setup.outputs.development_account_id }}"
            ROLE_NAME="GitHubActionsSESRole"
            echo "Using development account for infrastructure: $ACCOUNT_ID"
          else
            ACCOUNT_ID="${{ vars.MANAGEMENT_ACCOUNT_ID }}"
            ROLE_NAME="GitHubActionsSSORole"
            echo "Using management account for infrastructure: $ACCOUNT_ID"
          fi
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "role_name=$ROLE_NAME" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ steps.get-infra-account.outputs.account_id }}:role/${{ steps.get-infra-account.outputs.role_name }}
          aws-region: ${{ env.INFRA_REGION }}
        continue-on-error: true

      - name: Configure AWS credentials via static credentials (fallback)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Handle State Locks
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "üîç Checking for existing Terraform state locks..."

          echo "üîÑ Proceeding with Terraform operations..."

      - name: Terraform Init
        id: init
        run: |
          terraform init -upgrade

      - name: Terraform Validate
        id: validate
        run: |
          terraform validate

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive

      - name: Terraform Plan
        id: tf-plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        env:
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ steps.get-infra-account.outputs.account_id }}
        run: |
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && steps.tf-plan.outcome == 'success'
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Infrastructure Deployment üèóÔ∏è
            #### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.tf-plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Terraform Apply
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        env:
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ steps.get-infra-account.outputs.account_id }}
        run: |
          terraform apply -auto-approve tfplan

      - name: Force Unlock Infrastructure on Failure
        if: failure() && ((github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'))
        run: |
          echo "üîç Attempting to force unlock infrastructure Terraform state after failure..."

          # Try to scan DynamoDB for any existing locks
          echo "üîç Scanning DynamoDB for existing infrastructure locks..."
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "magebase-terraform-locks-bootstrap" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "üîí Found $LOCK_COUNT existing infrastructure state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "üîì Attempting to force unlock infrastructure: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID" 2>/dev/null; then
                  echo "‚úÖ Successfully force unlocked infrastructure: $LOCK_ID"
                  break
                else
                  echo "‚ö†Ô∏è  Force unlock failed for infrastructure: $LOCK_ID"
                fi
              fi
            done
          else
            echo "‚ÑπÔ∏è  No infrastructure locks found in DynamoDB table"
          fi

          # Provide manual instructions
          echo ""
          echo "üìã If the automatic unlock failed, please manually force-unlock the infrastructure state:"
          echo "1. Find the lock ID from the failed infrastructure deployment step logs above"
          echo "2. Run: cd infra && terraform force-unlock -force <lock_id>"
          echo "3. Re-run the workflow"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.INFRA_REGION }}

      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: |
          terraform destroy -auto-approve

  # ===== VALIDATION & TESTING =====
  validate:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    needs: [infrastructure-deploy, bootstrap, sso-setup]
    permissions:
      id-token: write
      contents: read
    outputs:
      tf_plan_exitcode: ${{ steps.tf-plan.outputs.exitcode }}
    defaults:
      run:
        working-directory: infra/pipeline/main-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Get Validation Account ID
        id: get-validation-account
        run: |
          # Use development account if SSO setup succeeded, otherwise use management account
          if [ "${{ needs.sso-setup.result }}" == "success" ] && [ -n "${{ needs.sso-setup.outputs.development_account_id }}" ]; then
            ACCOUNT_ID="${{ needs.sso-setup.outputs.development_account_id }}"
            ROLE_NAME="GitHubActionsSESRole"
            echo "Using development account for validation: $ACCOUNT_ID"
          else
            ACCOUNT_ID="${{ vars.MANAGEMENT_ACCOUNT_ID }}"
            ROLE_NAME="GitHubActionsSSORole"
            echo "Using management account for validation: $ACCOUNT_ID"
          fi
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "role_name=$ROLE_NAME" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ steps.get-validation-account.outputs.account_id }}:role/${{ steps.get-validation-account.outputs.role_name }}
          aws-region: ${{ env.INFRA_REGION }}
        continue-on-error: true

      - name: Configure AWS credentials via static credentials (fallback)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Handle State Locks
        run: |
          echo "üîç Checking for existing Terraform state locks..."

          # Scan DynamoDB table for any existing locks
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "magebase-terraform-locks-bootstrap" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          # Check if we found any lock items
          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "üîí Found $LOCK_COUNT existing state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "üîì Force unlocking state with ID: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID"; then
                  echo "‚úÖ Successfully unlocked: $LOCK_ID"
                else
                  echo "‚ö†Ô∏è  Force unlock failed for: $LOCK_ID"
                  # Continue anyway - sometimes locks are stale and will be overwritten
                fi
              else
                echo "‚ö†Ô∏è  Could not extract lock ID from item $i"
              fi
            done
          else
            echo "‚úÖ No state locks found"
          fi

          echo "üîÑ Proceeding with Terraform operations..."

      - name: Terraform Init
        id: init
        run: |
          terraform init -upgrade

      - name: Terraform Validate
        id: validate
        run: |
          terraform validate

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive

      - name: Terraform Plan
        id: tf-plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        run: |
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && steps.tf-plan.outcome == 'success'
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Validate üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.tf-plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  test-terraform:
    name: Test Terraform Configuration
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Test Development Configuration
        working-directory: infra/pipeline/main-infrastructure
        run: |
          terraform init -backend=false
          terraform plan -var-file="dev.tfvars" -no-color -out=tfplan-dev
          terraform show -json tfplan-dev > tfplan-dev.json

      - name: Test Production Configuration
        working-directory: infra/pipeline/main-infrastructure
        run: |
          terraform plan -var-file="prod.tfvars" -no-color -out=tfplan-prod
          terraform show -json tfplan-prod > tfplan-prod.json

      - name: Validate Plan Outputs
        run: |
          # Check that plans were generated successfully
          if [ ! -f "infra/pipeline/main-infrastructure/tfplan-dev.json" ] || [ ! -f "infra/pipeline/main-infrastructure/tfplan-prod.json" ]; then
            echo "‚ùå Plan files not generated"
            exit 1
          fi

          # Check for errors in plans
          if grep -q '"error"' infra/pipeline/main-infrastructure/tfplan-dev.json || grep -q '"error"' infra/pipeline/main-infrastructure/tfplan-prod.json; then
            echo "‚ùå Errors found in terraform plans"
            cat infra/pipeline/main-infrastructure/tfplan-dev.json
            cat infra/pipeline/main-infrastructure/tfplan-prod.json
            exit 1
          fi

          echo "‚úÖ Terraform plans validated successfully"

  security-scan:
    name: Security and Compliance Scan
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "config"
          scan-ref: "./terraform"
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

  notify:
    name: Deployment Results
    runs-on: ubuntu-latest
    needs:
      [
        sso-setup,
        bootstrap,
        infrastructure-deploy,
        validate,
        test-terraform,
        security-scan,
      ]
    if: always()

    steps:
      - name: Create deployment summary
        run: |
          echo "## üöÄ Unified Infrastructure Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # SSO Setup Results
          if [ "${{ needs.sso-setup.result }}" == "success" ]; then
            echo "‚úÖ **AWS Organizations & SSO:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.sso-setup.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è **AWS Organizations & SSO:** Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **AWS Organizations & SSO:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Bootstrap Results
          if [ "${{ needs.bootstrap.result }}" == "success" ]; then
            echo "‚úÖ **Terraform State Backend:** Bootstrapped successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform State Backend:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Infrastructure Deployment Results
          if [ "${{ needs.infrastructure-deploy.result }}" == "success" ]; then
            echo "‚úÖ **Infrastructure Deployment:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Infrastructure Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Validation Results
          if [ "${{ needs.validate.result }}" == "success" ]; then
            echo "‚úÖ **Terraform Validation:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform Validation:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Testing Results
          if [ "${{ needs.test-terraform.result }}" == "success" ]; then
            echo "‚úÖ **Terraform Testing:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Terraform Testing:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Security Scan Results
          if [ "${{ needs.security-scan.result }}" == "success" ]; then
            echo "‚úÖ **Security Scan:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Security Scan:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Architecture:" >> $GITHUB_STEP_SUMMARY
          echo "- **Cloud Provider:** Hetzner Cloud (k3s)" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** Singapore (ap-southeast-1)" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Organizations:** Multi-account setup" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS SSO:** Centralized identity management" >> $GITHUB_STEP_SUMMARY
          echo "- **Terraform State:** S3 + DynamoDB backend" >> $GITHUB_STEP_SUMMARY
          echo "- **DNS:** Cloudflare" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Registry:** GitHub Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "- **GitOps:** ArgoCD" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring:** Prometheus + Grafana" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Quick Links:" >> $GITHUB_STEP_SUMMARY
          echo "- [Application](https://magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [ArgoCD](https://argocd.magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [Grafana](https://grafana.magebase.dev)" >> $GITHUB_STEP_SUMMARY
          echo "- [Kubeconfig](https://github.com/magebase/site/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
