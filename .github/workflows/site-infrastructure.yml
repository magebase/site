name: Site Infrastructure Deployment

# This workflow handles the deployment of site-specific infrastructure resources
# including SES users, Cloudflare DNS/CDN, and Hetzner object storage.
# It uses dedicated AWS IAM users for SES instead of assuming roles in different accounts.

on:
  push:
    branches: [main]
    paths:
      - "infra/pipeline/site-infrastructure/**"
      - ".github/workflows/site-infrastructure.yml"
  pull_request:
    branches: [main]
    paths:
      - "infra/pipeline/site-infrastructure/**"
      - ".github/workflows/site-infrastructure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy infrastructure to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
      action:
        description: "Action to perform"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
          - cleanup
          - plan-apply

env:
  TF_VERSION: "1.8.0"
  TF_WORKING_DIR: infra/pipeline/site-infrastructure
  INFRA_REGION: ap-southeast-1
  SSO_REGION: us-east-1

jobs:
  site-infrastructure:
    name: "Site Infrastructure (${{ github.event.inputs.environment || 'dev' }})"
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/${{ vars.AWS_PIPELINE_ROLE }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Get Environment
        id: get-env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          echo "üåç Environment: $ENVIRONMENT"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

      - name: Initialize Terraform
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üîß Initializing Terraform..."
          terraform init -reconfigure

      - name: Clean Orphaned Resources
        if: github.event.inputs.action == 'cleanup' || contains(github.event.inputs.action, 'cleanup')
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_hetzner_region: ${{ vars.HTZ_REGION || 'fsn1' }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          AWS_SSO_START_URL: ${{ secrets.AWS_SSO_START_URL }}
          AWS_SSO_REGION: ${{ env.SSO_REGION }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "üßπ Cleaning up orphaned resources from state..."

          # Remove orphaned Hetzner Object Storage resources
          terraform state rm module.hetzner_object_storage.minio_s3_bucket_versioning.active_storage || echo "Resource not found"
          terraform state rm module.hetzner_object_storage.minio_s3_bucket.active_storage || echo "Resource not found"
          terraform state rm module.hetzner_object_storage.minio_s3_bucket_versioning.postgres_backups || echo "Resource not found"
          terraform state rm module.hetzner_object_storage.minio_s3_bucket.postgres_backups || echo "Resource not found"
          terraform state rm module.hetzner_object_storage.aws_s3_bucket.postgres_backups || echo "Resource not found"

          echo "‚úÖ Orphaned resources cleaned up"

      - name: Terraform Plan
        if: github.event.inputs.action == 'plan' || github.event_name == 'pull_request' || github.event.inputs.action == 'plan-apply'
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_hetzner_region: ${{ vars.HTZ_REGION || 'fsn1' }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          AWS_SSO_START_URL: ${{ secrets.AWS_SSO_START_URL }}
          AWS_SSO_REGION: ${{ env.SSO_REGION }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "üìã Planning infrastructure for $ENVIRONMENT environment..."

          terraform plan \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -var-file="${ENVIRONMENT}.tfvars" \
            -out=tfplan

          echo "‚úÖ Plan completed successfully"

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply'
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_hetzner_region: ${{ vars.HTZ_REGION || 'fsn1' }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          AWS_SSO_START_URL: ${{ secrets.AWS_SSO_START_URL }}
          AWS_SSO_REGION: ${{ env.SSO_REGION }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "üöÄ Applying infrastructure for $ENVIRONMENT environment..."

          terraform apply \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -var-file="${ENVIRONMENT}.tfvars" \
            -auto-approve

          echo "‚úÖ Apply completed successfully"

          # Capture SES user credentials from Terraform outputs
          echo "üîë Capturing SES user credentials..."

          # Get SES user name
          SES_USER_NAME=$(terraform output -raw ses_user_name 2>/dev/null || echo "")
          if [ -n "$SES_USER_NAME" ]; then
            echo "SES_USER_NAME=$SES_USER_NAME" >> $GITHUB_ENV
            echo "‚úÖ SES User Name: $SES_USER_NAME"
          fi

          # Get SES access key ID
          SES_ACCESS_KEY_ID=$(terraform output -raw ses_access_key_id 2>/dev/null || echo "")
          if [ -n "$SES_ACCESS_KEY_ID" ]; then
            echo "SES_ACCESS_KEY_ID=$SES_ACCESS_KEY_ID" >> $GITHUB_ENV
            echo "‚úÖ SES Access Key ID captured"
          fi

          # Get SES secret access key
          SES_SECRET_ACCESS_KEY=$(terraform output -raw ses_secret_access_key 2>/dev/null || echo "")
          if [ -n "$SES_SECRET_ACCESS_KEY" ]; then
            echo "SES_SECRET_ACCESS_KEY=$SES_SECRET_ACCESS_KEY" >> $GITHUB_ENV
            echo "‚úÖ SES Secret Access Key captured"
          fi

      - name: Generate Terraform Outputs
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üìä Generating Terraform outputs for sharing..."
          terraform output -json > terraform-outputs.json
          echo "‚úÖ Outputs generated: terraform-outputs.json"

      - name: Create GitHub Release
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: site-outputs-${{ github.run_id }}
          name: Site Infrastructure Outputs ${{ github.run_id }}
          body: |
            Latest Terraform outputs from site infrastructure deployment.

            **Environment:** ${{ github.event.inputs.environment || 'dev' }}
            **Generated:** ${{ github.event.head_commit.timestamp }}
            **Commit:** ${{ github.sha }}
            **Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            This release contains the terraform-outputs.json file with all site infrastructure outputs that can be consumed by dependent repositories.
          files: terraform-outputs.json
          draft: false
          prerelease: false
          generate_release_notes: true

      - name: Display Release Information
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        run: |
          echo "## üì¶ Site Infrastructure Outputs Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Release Created:** site-outputs-${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "üìä **Outputs File:** terraform-outputs.json" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Download URL:** ${{ github.server_url }}/${{ github.repository }}/releases/download/site-outputs-${{ github.run_id }}/terraform-outputs.json" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Dependent Repositories:" >> $GITHUB_STEP_SUMMARY
          echo "- Download the terraform-outputs.json from this release" >> $GITHUB_STEP_SUMMARY
          echo "- Parse the JSON to extract required values" >> $GITHUB_STEP_SUMMARY
          echo "- Use outputs in your Terraform configurations" >> $GITHUB_STEP_SUMMARY

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_hetzner_region: ${{ vars.HTZ_REGION || 'fsn1' }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          AWS_SSO_START_URL: ${{ secrets.AWS_SSO_START_URL }}
          AWS_SSO_REGION: ${{ env.SSO_REGION }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "üóëÔ∏è Destroying infrastructure for $ENVIRONMENT environment..."

          terraform destroy \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -var-file="${ENVIRONMENT}.tfvars" \
            -auto-approve

          echo "‚úÖ Destroy completed successfully"

      - name: Display SES Credentials (for debugging)
        if: env.SES_USER_NAME
        run: |
          echo "üîê SES User Credentials Generated:"
          echo "User Name: ${{ env.SES_USER_NAME }}"
          echo "Access Key ID: ${{ env.SES_ACCESS_KEY_ID }}"
          echo "Secret Access Key: ***masked***"
          echo ""
          echo "‚ö†Ô∏è  These credentials should be stored securely in your deployment environment"
          echo "   Consider using GitHub Secrets or your secret management system"
