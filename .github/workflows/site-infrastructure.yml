name: Site Infrastructure Deployment

# This workflow handles the deployment of site-specific infrastructure resources
# including SES users, Cloudflare DNS/CDN, and Hetzner object storage.
# It uses dedicated AWS IAM users for SES instead of assuming roles in different accounts.

on:
  push:
    branches: [main]
    paths:
      - 'infra/pipeline/site-infrastructure/**'
      - '.github/workflows/site-infrastructure.yml'
  pull_request:
    branches: [main]
    paths:
      - 'infra/pipeline/site-infrastructure/**'
      - '.github/workflows/site-infrastructure.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy infrastructure to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
          - cleanup
          - plan-apply

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  TF_VERSION: '1.8.0'
  TF_WORKING_DIR: infra/pipeline/site-infrastructure
  INFRA_REGION: ap-southeast-1
  SSO_REGION: us-east-1
  TF_VAR_google_studio_api_key: ${{ secrets.GOOGLE_STUDIO_API_KEY }}
  TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
  TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}

jobs:
  site-infrastructure:
    name: "Site Infrastructure (${{ github.event.inputs.environment || 'dev' }})"
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    permissions:
      id-token: write
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.MANAGEMENT_ACCOUNT_ID }}:role/${{ vars.AWS_PIPELINE_ROLE }}
          aws-region: ${{ env.INFRA_REGION }}

      - name: Get Environment
        id: get-env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          echo "🌍 Environment: $ENVIRONMENT"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

      - name: Initialize Terraform
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "🔧 Initializing Terraform..."
          terraform init -reconfigure

      - name: Clean Orphaned Resources
        if: github.event.inputs.action == 'cleanup' || contains(github.event.inputs.action, 'cleanup')
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_google_studio_api_key: ${{ secrets.GOOGLE_STUDIO_API_KEY }}
          TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"

      - name: Terraform Plan
        if: github.event.inputs.action == 'plan' || github.event_name == 'pull_request' || github.event.inputs.action == 'plan-apply'
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_google_studio_api_key: ${{ secrets.GOOGLE_STUDIO_API_KEY }}
          TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "📋 Planning infrastructure for $ENVIRONMENT environment..."

          terraform plan \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -out=tfplan

          echo "✅ Plan completed successfully"

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply'
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_google_studio_api_key: ${{ secrets.GOOGLE_STUDIO_API_KEY }}
          TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "🚀 Applying infrastructure for $ENVIRONMENT environment..."

          terraform apply \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -auto-approve

          echo "✅ Apply completed successfully"

          # Capture SES user credentials from Terraform outputs
          echo "🔑 Capturing SES user credentials..."

          # Get SES user name
          SES_USER_NAME=$(terraform output -raw ses_user_name 2>/dev/null || echo "")
          if [ -n "$SES_USER_NAME" ]; then
            echo "SES_USER_NAME=$SES_USER_NAME" >> $GITHUB_ENV
            echo "✅ SES User Name: $SES_USER_NAME"
          fi

          # Get SES access key ID
          SES_ACCESS_KEY_ID=$(terraform output -raw ses_access_key_id 2>/dev/null || echo "")
          if [ -n "$SES_ACCESS_KEY_ID" ]; then
            echo "SES_ACCESS_KEY_ID=$SES_ACCESS_KEY_ID" >> $GITHUB_ENV
            echo "✅ SES Access Key ID captured"
          fi

          # Get SES secret access key
          SES_SECRET_ACCESS_KEY=$(terraform output -raw ses_secret_access_key 2>/dev/null || echo "")
          if [ -n "$SES_SECRET_ACCESS_KEY" ]; then
            echo "SES_SECRET_ACCESS_KEY=$SES_SECRET_ACCESS_KEY" >> $GITHUB_ENV
            echo "✅ SES Secret Access Key captured"
          fi

          # Capture Cloudflare R2 endpoint from base-infrastructure remote state
          echo "☁️ Capturing Cloudflare R2 endpoint from base-infrastructure..."
          CLOUDFLARE_R2_ENDPOINT=$(terraform output -raw -state=../base-infrastructure/terraform.tfstate cloudflare_r2_endpoint 2>/dev/null || echo "")
          if [ -n "$CLOUDFLARE_R2_ENDPOINT" ]; then
            echo "CLOUDFLARE_R2_ENDPOINT=$CLOUDFLARE_R2_ENDPOINT" >> $GITHUB_ENV
            echo "✅ Cloudflare R2 Endpoint: $CLOUDFLARE_R2_ENDPOINT"
          else
            echo "⚠️ Cloudflare R2 endpoint not found, using default"
            echo "CLOUDFLARE_R2_ENDPOINT=https://storage.magebase.dev" >> $GITHUB_ENV
          fi

      - name: Process Template Files
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        env:
          CLOUDFLARE_R2_ACCESS_KEY_B64: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          CLOUDFLARE_R2_SECRET_KEY_B64: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          CLOUDFLARE_R2_ENDPOINT: ${{ env.CLOUDFLARE_R2_ENDPOINT }}
        run: |
          echo "🔧 Processing template files..."

          # Base64 encode the Cloudflare R2 credentials for Kubernetes secrets
          if [ -n "${CLOUDFLARE_R2_ACCESS_KEY_B64}" ]; then
            CLOUDFLARE_R2_ACCESS_KEY_B64=$(echo -n "${CLOUDFLARE_R2_ACCESS_KEY_B64}" | base64)
            echo "✅ Cloudflare R2 Access Key encoded"
          fi

          if [ -n "${CLOUDFLARE_R2_SECRET_KEY_B64}" ]; then
            CLOUDFLARE_R2_SECRET_KEY_B64=$(echo -n "${CLOUDFLARE_R2_SECRET_KEY_B64}" | base64)
            echo "✅ Cloudflare R2 Secret Key encoded"
          fi

          # Export variables for envsubst
          export CLOUDFLARE_R2_ACCESS_KEY_B64
          export CLOUDFLARE_R2_SECRET_KEY_B64
          export CLOUDFLARE_R2_ENDPOINT

          # Function to process template files
          process_templates() {
            local template_dir="$1"
            local output_dir="$2"

            echo "📁 Processing templates in: $template_dir"

            # Find all .tpl files and process them
            find "$template_dir" -name "*.tpl" -type f | while read -r tpl_file; do
              # Get the output file path (remove .tpl extension)
              output_file="${tpl_file%.tpl}"

              # If output_dir is specified, put output files there
              if [ -n "$output_dir" ]; then
                # Get relative path from template_dir
                rel_path="${tpl_file#$template_dir/}"
                rel_path="${rel_path%.tpl}"
                output_file="$output_dir/$rel_path"
                mkdir -p "$(dirname "$output_file")"
              fi

              echo "📝 Processing: $tpl_file -> $output_file"

              # Process the template file with environment variable substitution
              envsubst < "$tpl_file" > "$output_file"

              echo "✅ Processed: $output_file"
            done
          }

          # Process base infrastructure templates
          process_templates "infra/pipeline/base-infrastructure/extra-manifests" "infra/pipeline/base-infrastructure/extra-manifests"

          # Process site infrastructure templates if they exist
          if [ -d "infra/pipeline/site-infrastructure/extra-manifests" ]; then
            process_templates "infra/pipeline/site-infrastructure/extra-manifests" "infra/pipeline/site-infrastructure/extra-manifests"
          fi

          echo "🎉 Template processing completed!"

      - name: Generate Terraform Outputs
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "📊 Generating Terraform outputs for sharing..."
          terraform output -json > terraform-outputs.json
          echo "✅ Outputs generated: terraform-outputs.json"

      - name: Create GitHub Release
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: site-outputs-${{ github.run_id }}
          name: Site Infrastructure Outputs ${{ github.run_id }}
          body: |
            Latest Terraform outputs from site infrastructure deployment.

            **Environment:** ${{ github.event.inputs.environment || 'dev' }}
            **Generated:** ${{ github.event.head_commit.timestamp }}
            **Commit:** ${{ github.sha }}
            **Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            This release contains the terraform-outputs.json file with all site infrastructure outputs that can be consumed by dependent repositories.
          files: terraform-outputs.json
          draft: false
          prerelease: false
          generate_release_notes: true

      - name: Display Release Information
        if: success() && (github.event.inputs.action == 'apply' || github.event_name == 'push' || github.event.inputs.action == 'plan-apply')
        run: |
          echo "## 📦 Site Infrastructure Outputs Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Release Created:** site-outputs-${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "📊 **Outputs File:** terraform-outputs.json" >> $GITHUB_STEP_SUMMARY
          echo "🔗 **Download URL:** ${{ github.server_url }}/${{ github.repository }}/releases/download/site-outputs-${{ github.run_id }}/terraform-outputs.json" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📋 Dependent Repositories:" >> $GITHUB_STEP_SUMMARY
          echo "- Download the terraform-outputs.json from this release" >> $GITHUB_STEP_SUMMARY
          echo "- Parse the JSON to extract required values" >> $GITHUB_STEP_SUMMARY
          echo "- Use outputs in your Terraform configurations" >> $GITHUB_STEP_SUMMARY

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_ruby_llm_api_key: ${{ secrets.RUBY_LLM_API_KEY }}
          TF_VAR_cloudflare_r2_access_key_id: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_ACCESS_KEY }}
          TF_VAR_cloudflare_r2_secret_access_key: ${{ secrets.CLOUDFLARE_OBJECT_STORAGE_SECRET_KEY }}
          TF_VAR_environment_account_id: ${{ vars.MANAGEMENT_ACCOUNT_ID }}
          TF_VAR_cloudflare_region: ${{ vars.CF_REGION || 'EU' }}
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_google_studio_api_key: ${{ secrets.GOOGLE_STUDIO_API_KEY }}
          TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY }}
        run: |
          ENVIRONMENT="${{ steps.get-env.outputs.environment }}"
          echo "🗑️ Destroying infrastructure for $ENVIRONMENT environment..."

          terraform destroy \
            -var="management_account_id=${{ vars.MANAGEMENT_ACCOUNT_ID }}" \
            -auto-approve

          echo "✅ Destroy completed successfully"

      - name: Display SES Credentials (for debugging)
        if: env.SES_USER_NAME
        run: |
          echo "🔐 SES User Credentials Generated:"
          echo "User Name: ${{ env.SES_USER_NAME }}"
          echo "Access Key ID: ${{ env.SES_ACCESS_KEY_ID }}"
          echo "Secret Access Key: ***masked***"
          echo ""
          echo "⚠️  These credentials should be stored securely in your deployment environment"
          echo "   Consider using GitHub Secrets or your secret management system"
