name: Site Infrastructure Deployment

# This workflow handles the deployment of site-specific infrastructure resources
# including SES, Cloudflare DNS/CDN, and Hetzner object storage.
# DEPENDENCY: This workflow requires unified-infrastructure to run successfully first.
# It will automatically trigger after unified-infrastructure completes, or can be run manually
# after verifying unified-infrastructure has succeeded.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_run:
    workflows: ["Unified Infrastructure Deployment"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy infrastructure to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
      action:
        description: "Action to perform"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      base_infrastructure_status:
        description: "Status of base infrastructure deployment (use 'completed' if base infra is ready)"
        required: false
        default: "unknown"
        type: string

env:
  TF_VERSION: "1.8.0"
  AWS_REGION: us-east-1 # Organizations must be in us-east-1
  SSO_REGION: ap-southeast-1
  INFRA_REGION: ap-southeast-1

jobs:
  site-infrastructure-deploy:
    name: "Site Infrastructure Deployment"
    runs-on: self-hosted
    permissions:
      id-token: write
      contents: read
    # Skip planning if base infrastructure status is not confirmed
    if: >
      (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan' || github.event.inputs.base_infrastructure_status == 'completed') &&
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    defaults:
      run:
        working-directory: infra/pipeline/site-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract Environment from Triggering Workflow
        if: github.event_name == 'workflow_run'
        run: |
          # Extract environment from the triggering workflow
          TRIGGERING_WORKFLOW="${{ github.event.workflow_run.name }}"
          echo "🔗 Triggered by workflow: $TRIGGERING_WORKFLOW"

          # Try to extract environment from workflow inputs or outputs
          # For now, default to dev, but this can be enhanced to parse the triggering workflow's inputs
          ENVIRONMENT="dev"
          echo "🌍 Inferred environment: $ENVIRONMENT"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate Base Infrastructure Status
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.event.inputs.base_infrastructure_status }}" != "completed" ]; then
            echo "❌ Base infrastructure deployment status not confirmed"
            echo "📋 Please ensure base infrastructure (k3s cluster) is deployed before running site infrastructure"
            echo "💡 Set base_infrastructure_status to 'completed' when ready"
            exit 1
          fi
          echo "✅ Base infrastructure status confirmed"

      - name: Validate Unified Infrastructure Status
        run: |
          echo "🔍 Validating Unified Infrastructure Deployment status..."

          # Check if this was triggered by unified-infrastructure workflow
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
              echo "✅ Site infrastructure triggered by successful unified infrastructure deployment"
              echo "🔗 Triggering workflow: ${{ github.event.workflow_run.name }}"
              echo "📋 Triggering run ID: ${{ github.event.workflow_run.id }}"
            else
              echo "❌ Site infrastructure triggered by failed unified infrastructure deployment"
              echo "🔗 Triggering workflow: ${{ github.event.workflow_run.name }}"
              echo "📋 Triggering conclusion: ${{ github.event.workflow_run.conclusion }}"
              exit 1
            fi
          else
            # For manual triggers, check if unified-infrastructure has run recently
            echo "🔍 Checking for recent unified infrastructure deployment..."

            # Get the latest run of the unified infrastructure workflow
            LATEST_RUN=$(gh run list --workflow="Unified Infrastructure Deployment" --limit=1 --json conclusion,status,createdAt --jq '.[0]')

            if [ -z "$LATEST_RUN" ]; then
              echo "❌ No unified infrastructure deployment found"
              echo "📋 Please run the 'Unified Infrastructure Deployment' workflow first"
              echo "💡 This ensures all base infrastructure and accounts are properly configured"
              exit 1
            fi

            CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.conclusion')
            STATUS=$(echo "$LATEST_RUN" | jq -r '.status')
            CREATED_AT=$(echo "$LATEST_RUN" | jq -r '.createdAt')

            echo "📋 Latest unified infrastructure run:"
            echo "  Status: $STATUS"
            echo "  Conclusion: $CONCLUSION"
            echo "  Created: $CREATED_AT"

            if [ "$CONCLUSION" != "success" ]; then
              echo "❌ Latest unified infrastructure deployment did not succeed"
              echo "📋 Conclusion: $CONCLUSION"
              echo "💡 Please ensure the unified infrastructure deployment completes successfully first"
              exit 1
            fi

            # Check if the run is recent (within last 24 hours)
            CREATED_TIMESTAMP=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || date -d "$CREATED_AT" +%s)
            CURRENT_TIMESTAMP=$(date +%s)
            TIME_DIFF=$((CURRENT_TIMESTAMP - CREATED_TIMESTAMP))
            MAX_AGE=$((24 * 60 * 60)) # 24 hours in seconds

            if [ $TIME_DIFF -gt $MAX_AGE ]; then
              echo "⚠️  Latest unified infrastructure deployment is older than 24 hours"
              echo "📋 Age: $((TIME_DIFF / 3600)) hours"
              echo "💡 Consider running a fresh unified infrastructure deployment"
            else
              echo "✅ Unified infrastructure deployment is recent ($((TIME_DIFF / 3600)) hours old)"
            fi

            echo "✅ Unified infrastructure validation passed"
          fi

      - name: Get Infrastructure Account ID
        id: get-infra-account
        run: |
          # For site infrastructure, we typically use the development account
          # This can be overridden based on environment if needed
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"

          # Try to get account IDs from triggering workflow outputs first
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            DEV_ACCOUNT_ID="${{ github.event.workflow_run.outputs.development_account_id }}"
            PROD_ACCOUNT_ID="${{ github.event.workflow_run.outputs.production_account_id }}"

            if [ -n "$DEV_ACCOUNT_ID" ] && [ -n "$PROD_ACCOUNT_ID" ]; then
              echo "✅ Using account IDs from triggering workflow outputs"
            else
              echo "⚠️  Triggering workflow outputs not available, falling back to repository variables"
              DEV_ACCOUNT_ID="${{ vars.DEVELOPMENT_ACCOUNT_ID }}"
              PROD_ACCOUNT_ID="${{ vars.PRODUCTION_ACCOUNT_ID }}"
            fi
          else
            # For manual triggers, use repository variables
            DEV_ACCOUNT_ID="${{ vars.DEVELOPMENT_ACCOUNT_ID }}"
            PROD_ACCOUNT_ID="${{ vars.PRODUCTION_ACCOUNT_ID }}"
          fi

          if [ "$ENVIRONMENT" == "prod" ] || [ "$ENVIRONMENT" == "uat" ]; then
            echo "Using production account for site infrastructure (environment: $ENVIRONMENT)"
            ACCOUNT_ID="$PROD_ACCOUNT_ID"
          else
            echo "Using development account for site infrastructure (environment: $ENVIRONMENT)"
            ACCOUNT_ID="$DEV_ACCOUNT_ID"
          fi

          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "ses_access_key_id=" >> $GITHUB_OUTPUT
          echo "ses_secret_access_key=" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials via OIDC
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ steps.get-infra-account.outputs.account_id }}:role/GitHubActionsSSORole
          aws-region: ${{ env.INFRA_REGION }}
        continue-on-error: true

      - name: Handle State Locks
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan') || (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "🔍 Checking for existing Terraform state locks..."

          # Wait for any existing locks to be released (with timeout)
          MAX_WAIT=300  # 5 minutes
          WAIT_COUNT=0

          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            LOCK_ITEMS=$(aws dynamodb scan \
              --table-name "magebase-terraform-locks-bootstrap" \
              --region ${{ env.INFRA_REGION }} \
              --query 'Items[?attribute_exists(LockID)]' \
              --output json 2>/dev/null || echo "[]")

            LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

            if [ "$LOCK_COUNT" -eq 0 ]; then
              echo "✅ No state locks found - proceeding with Terraform operations"
              break
            else
              echo "🔒 Found $LOCK_COUNT existing state lock(s), waiting..."
              for i in $(seq 0 $(($LOCK_COUNT - 1))); do
                LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
                LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")
                if [ -n "$LOCK_ID" ]; then
                  echo "  Lock ID: $LOCK_ID"
                  echo "  Info: $LOCK_INFO"
                fi
              done

              WAIT_COUNT=$((WAIT_COUNT + 30))
              if [ $WAIT_COUNT -lt $MAX_WAIT ]; then
                echo "⏳ Waiting 30 seconds before checking again... ($WAIT_COUNT/$MAX_WAIT seconds)"
                sleep 30
              fi
            fi
          done

          if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
            echo "❌ Timeout waiting for state locks to be released"
            echo "🔓 Attempting to force unlock existing locks..."

            # Force unlock any remaining locks
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              if [ -n "$LOCK_ID" ]; then
                echo "🔓 Force unlocking: $LOCK_ID"
                if terraform force-unlock -force "$LOCK_ID" 2>/dev/null; then
                  echo "✅ Successfully force unlocked: $LOCK_ID"
                  break
                else
                  echo "⚠️  Force unlock failed for: $LOCK_ID"
                fi
              fi
            done
          fi

          echo "🔄 Proceeding with Terraform operations..."

      - name: Terraform Init
        id: init
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          terraform init -upgrade -backend-config="key=magebase/site-infrastructure/${ENVIRONMENT}/terraform.tfstate"

      - name: Terraform Validate
        id: validate
        run: |
          terraform validate

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive

      - name: Terraform Plan
        id: tf-plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ steps.get-infra-account.outputs.account_id }}
          TF_VAR_aws_ses_access_key_id: ${{ steps.get-infra-account.outputs.ses_access_key_id }}
          TF_VAR_aws_ses_secret_access_key: ${{ steps.get-infra-account.outputs.ses_secret_access_key }}
          TF_VAR_hetzner_object_storage_access_key: ${{ secrets.HETZNER_OBJECT_STORAGE_ACCESS_KEY || '' }}
          TF_VAR_hetzner_object_storage_secret_key: ${{ secrets.HETZNER_OBJECT_STORAGE_SECRET_KEY || '' }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY || '' }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET || '' }}
        run: |
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Terraform Plan (Push to Main)
        id: tf-plan-main
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ steps.get-infra-account.outputs.account_id }}
          TF_VAR_aws_ses_access_key_id: ${{ steps.get-infra-account.outputs.ses_access_key_id }}
          TF_VAR_aws_ses_secret_access_key: ${{ steps.get-infra-account.outputs.ses_secret_access_key }}
          TF_VAR_hetzner_object_storage_access_key: ${{ secrets.HETZNER_OBJECT_STORAGE_ACCESS_KEY || '' }}
          TF_VAR_hetzner_object_storage_secret_key: ${{ secrets.HETZNER_OBJECT_STORAGE_SECRET_KEY || '' }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY || '' }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET || '' }}
        run: |
          echo "🚀 Running Terraform plan for site infrastructure deployment..."

          # Debug: Check if secrets are being passed
          echo "🔍 Debug: Checking environment variables..."
          if [ -z "$TF_VAR_stripe_api_key" ]; then
            echo "⚠️  TF_VAR_stripe_api_key is empty or not set"
          else
            echo "✅ TF_VAR_stripe_api_key is set (length: ${#TF_VAR_stripe_api_key})"
          fi

          # Retry logic for state lock conflicts
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "📋 Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"

            if terraform plan -no-color -out=tfplan; then
              echo "✅ Terraform plan completed successfully"
              echo "📄 Plan file created: tfplan"

              # Verify the plan file was created
              if [ -f "tfplan" ]; then
                echo "✅ Plan file verified: $(ls -la tfplan)"
              else
                echo "❌ Plan file was not created despite successful plan command"
                exit 1
              fi
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️  Terraform plan failed, retrying in 30 seconds..."
                sleep 30
              else
                echo "❌ Terraform plan failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Update Pull Request
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && (steps.tf-plan.outcome == 'success' || steps.tf-plan-main.outcome == 'success')
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout || steps.tf-plan-main.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const planOutcome = '${{ steps.tf-plan.outcome }}' === 'success' ? '${{ steps.tf-plan.outcome }}' : '${{ steps.tf-plan-main.outcome }}';
            const output = `#### Site Infrastructure Deployment 🏗️
            #### Terraform Format and Validate 🖌\`${{ steps.fmt.outcome }}\`
            #### Terraform Plan 📖\`${planOutcome}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Terraform Apply
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'dev' }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_aws_ses_account_id: ${{ steps.get-infra-account.outputs.account_id }}
          TF_VAR_aws_ses_access_key_id: ${{ steps.get-infra-account.outputs.ses_access_key_id }}
          TF_VAR_aws_ses_secret_access_key: ${{ steps.get-infra-account.outputs.ses_secret_access_key }}
          TF_VAR_stripe_api_key: ${{ secrets.STRIPE_API_KEY || '' }}
          TF_VAR_stripe_webhook_secret: ${{ secrets.STRIPE_WEBHOOK_SECRET || '' }}
        run: |
          echo "🚀 Applying site infrastructure changes..."

          # Check if tfplan exists, if not create it
          if [ ! -f "tfplan" ]; then
            echo "📋 No tfplan file found, creating plan first..."
            terraform plan -no-color -out=tfplan
          fi

          # Retry logic for state lock conflicts
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "📋 Apply attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"

            if terraform apply -auto-approve tfplan; then
              echo "✅ Site infrastructure apply completed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️  Site infrastructure apply failed, retrying in 30 seconds..."
                sleep 30
              else
                echo "❌ Site infrastructure apply failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Output Database Connection Information
        if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "🗄️ **Database Connection Information**"
          echo ""
          echo "The database URL is dynamically generated by CloudNativePG and stored in a Kubernetes Secret."
          echo ""
          echo "To retrieve the database connection string after deployment:"
          echo ""
          echo "1. **Get kubeconfig from workflow artifacts** (download from this run)"
          echo "2. **Set up kubectl access**:"
          echo "   export KUBECONFIG=/path/to/downloaded/kubeconfig"
          echo ""
          echo "3. **Retrieve the database URL**:"
          echo "   kubectl get secret magebase-db-creds -n magebase -o jsonpath='{.data.connection_string}' | base64 -d"
          echo ""
          echo "4. **View all database connection details**:"
          echo "   kubectl get secret magebase-db-creds -n magebase -o yaml"
          echo ""
          echo "The application deployment automatically uses this Secret for DATABASE_URL."

      - name: Force Unlock Site Infrastructure on Failure
        if: failure() && ((github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'))
        run: |
          echo "🔍 Attempting to force unlock site infrastructure Terraform state after failure..."

          # Try to scan DynamoDB for any existing locks
          echo "🔍 Scanning DynamoDB for existing site infrastructure locks..."
          LOCK_ITEMS=$(aws dynamodb scan \
            --table-name "magebase-terraform-locks-bootstrap" \
            --region ${{ env.INFRA_REGION }} \
            --query 'Items[?attribute_exists(LockID)]' \
            --output json 2>/dev/null || echo "[]")

          LOCK_COUNT=$(echo "$LOCK_ITEMS" | jq length 2>/dev/null || echo "0")

          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "🔒 Found $LOCK_COUNT existing site infrastructure state lock(s), attempting to force unlock..."

            # Process each lock item
            for i in $(seq 0 $(($LOCK_COUNT - 1))); do
              LOCK_ID=$(echo "$LOCK_ITEMS" | jq -r ".[$i].LockID.S" 2>/dev/null || echo "")
              LOCK_INFO=$(echo "$LOCK_ITEMS" | jq -r ".[$i].Info.S" 2>/dev/null || echo "")

              if [ -n "$LOCK_ID" ]; then
                echo "🔓 Attempting to force unlock site infrastructure: $LOCK_ID"
                echo "Lock info: $LOCK_INFO"

                # Attempt force unlock
                if terraform force-unlock -force "$LOCK_ID" 2>/dev/null; then
                  echo "✅ Successfully force unlocked site infrastructure: $LOCK_ID"
                  break
                else
                  echo "⚠️  Force unlock failed for site infrastructure: $LOCK_ID"
                fi
              fi
            done
          else
            echo "ℹ️  No site infrastructure locks found in DynamoDB table"
          fi

          # Provide manual instructions
          echo ""
          echo "📋 If the automatic unlock failed, please manually force-unlock the site infrastructure state:"
          echo "1. Find the lock ID from the failed site infrastructure deployment step logs above"
          echo "2. Run: cd infra/pipeline/site-infrastructure && terraform force-unlock -force <lock_id>"
          echo "3. Re-run the workflow"
        env:
          AWS_REGION: ${{ env.INFRA_REGION }}

      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: |
          terraform destroy -auto-approve
