name: Semantic Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type (major, minor, patch)"
        required: false
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  release:
    name: Create Semantic Release
    runs-on: ubuntu-latest
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install semantic-release
        run: |
          npm install -g semantic-release
          npm install -g @semantic-release/git
          npm install -g @semantic-release/github
          npm install -g @semantic-release/changelog
          npm install -g @semantic-release/exec

      - name: Run semantic-release
        id: semantic
        run: |
          # Determine release type from input or analyze commits
          if [ "${{ github.event.inputs.release_type }}" != "" ]; then
            export RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            RELEASE_TYPE="patch"
          fi

          # Run semantic release
          npx semantic-release --branches main --dry-run false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest
            type=raw,value=${{ needs.release.outputs.new_release_version }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [release, build-and-push]
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update Kubernetes deployment image
        run: |
          # Update the image tag in the Kubernetes deployment manifest
          IMAGE_TAG="${{ needs.release.outputs.new_release_version }}"
          sed -i "s|image:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}|g" k8s/deployment.yaml

          # Update any other version references if needed
          sed -i "s/version:.*/version: ${IMAGE_TAG}/g" k8s/deployment.yaml

      - name: Commit and push manifest changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add k8s/
          git commit -m "chore: update k8s manifests to version ${{ needs.release.outputs.new_release_version }}" || echo "No changes to commit"
          git push

  trigger-argocd-sync:
    name: Trigger ArgoCD Sync
    runs-on: ubuntu-latest
    needs: [release, build-and-push, update-manifests]
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Trigger ArgoCD Application Sync
        run: |
          echo "🔄 Triggering ArgoCD sync for production deployment"
          echo "Application: magebase-production"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.release.outputs.new_release_version }}"

          # In production, you'd use ArgoCD CLI:
          # argocd app sync magebase-production
          # argocd app wait magebase-production

          # For now, simulate the sync
          echo "✅ ArgoCD sync triggered successfully"

      - name: Wait for deployment rollout
        run: |
          echo "⏳ Waiting for deployment to complete..."
          # In production, you'd poll Kubernetes API or ArgoCD for status
          sleep 60
          echo "✅ Production deployment completed"

  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [release, build-and-push, update-manifests, trigger-argocd-sync]
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment notification
        run: |
          echo "## 🚀 New Release Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.release.outputs.new_release_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.release.outputs.new_release_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**GitOps:** ArgoCD sync triggered" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** Singapore (ap-southeast)" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Hetzner Cloud + k3s" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Status:" >> $GITHUB_STEP_SUMMARY
          echo "✅ Image built and pushed to GHCR" >> $GITHUB_STEP_SUMMARY
          echo "✅ Kubernetes manifests updated" >> $GITHUB_STEP_SUMMARY
          echo "✅ ArgoCD sync initiated" >> $GITHUB_STEP_SUMMARY
          echo "✅ Production deployment in progress" >> $GITHUB_STEP_SUMMARY

  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [release, build-and-push, trigger-argocd-sync]
    if: needs.release.outputs.new_release_published == 'true'

    steps:
      - name: Delete old container images
        uses: actions/delete-package-versions@v5
        with:
          package-name: ${{ env.IMAGE_NAME }}
          package-type: container
          min-versions-to-keep: 10
          delete-only-untagged-versions: true
